
/*
 * Catalog Services API
 *
 * Catalog Services Web API Documentation
 *
 * API version: 1.0.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"fmt"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type EntitiesApiService service

/* 
EntitiesApiService Returns entity with the specified business ID or GUID.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param entityId entityId is the GUID or BusinessId of the entity.
 * @param optional nil or *EntitiesApiApiEntitiesEntityIdGetOpts - Optional Parameters:
     * @param "Id" (optional.String) -  idType is either “GUID” or “Business” to indicate the type of ID being passed into the query. Note: The IDType parameter is not required to return data when EntityID is a GUID.


*/

type EntitiesApiApiEntitiesEntityIdGetOpts struct { 
	Id optional.String
}

func (a *EntitiesApiService) ApiEntitiesEntityIdGet(ctx context.Context, entityId string, localVarOptionals *EntitiesApiApiEntitiesEntityIdGetOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/entities({entityId})"
	localVarPath = strings.Replace(localVarPath, "{"+"entityId"+"}", fmt.Sprintf("%v", entityId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
EntitiesApiService Returns an entity in context of a product specification based on a guid path or business path
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *EntitiesApiApiEntitiesEntityInContextPostOpts - Optional Parameters:
     * @param "Parameters" (optional.Interface of EntityInContextRequest) -  parameters are the GUID or BUID path of a entity within a product specification.


*/

type EntitiesApiApiEntitiesEntityInContextPostOpts struct { 
	Parameters optional.Interface
}

func (a *EntitiesApiService) ApiEntitiesEntityInContextPost(ctx context.Context, localVarOptionals *EntitiesApiApiEntitiesEntityInContextPostOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/entities/EntityInContext"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/_*+json", "application/xml", "text/xml", "application/_*+xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Parameters.IsSet() {
		
		localVarOptionalParameters, localVarOptionalParametersok := localVarOptionals.Parameters.Value().(EntityInContextRequest)
		if !localVarOptionalParametersok {
				return nil, reportError("parameters should be EntityInContextRequest")
		}
		localVarPostBody = &localVarOptionalParameters
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
EntitiesApiService Returns entities that use given fact values according to the filter.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param entityType Entity Type is a list the entity types to look for comma separated e.g. Component, Charge.
 * @param elementFilterList &lt;main&gt;A list of &#39;fact value&#39; packets which define what fact-values you want to match on.  You can pass multiple packets into this query. Each packet is in the following:&lt;/main&gt;  &lt;sub&gt;1. [FACTVALUE; FACTVALUEGUIDS; MATCHALLFACTVALUES; CANNEVEREXIST; NOT]&lt;/sub&gt;  &lt;sub&gt;2. FACTVALUE - The schema element name that contains the fact values to filter on.&lt;/sub&gt;  &lt;sub&gt;3. FACTVALUEGUIDS - is a comma seperated list that represents all the fact values on which the query is filtering.&lt;/sub&gt;  &lt;sub&gt;4. MATCHALLFACTVALUES - is either TRUE or FALSE to specify whether the query results need to match ALL of these or just ANY.&lt;/sub&gt;  &lt;sub&gt;5. CANNEVEREXIST - either true or false to specify whether we want to return entities that lack the Element name (Optional)&lt;/sub&gt;  &lt;sub&gt;6. NOT - an optional parameter to allow the filter to be inverted&lt;/sub&gt;


*/
func (a *EntitiesApiService) ApiEntitiesEntityTypeFactelementfilterElementFilterListGet(ctx context.Context, entityType string, elementFilterList string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/entities({entityType})/factelementfilter({elementFilterList})"
	localVarPath = strings.Replace(localVarPath, "{"+"entityType"+"}", fmt.Sprintf("%v", entityType), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"elementFilterList"+"}", fmt.Sprintf("%v", elementFilterList), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
EntitiesApiService Returns a list of all entities that are parents of the supplied entity.
The list of parents is filtered based on the parent type parameter. If the query does not specify a type, all the  parent entities are returned regardless of type.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param guid guid is the GUID of the entity for which the query finds parents.
 * @param optional nil or *EntitiesApiApiEntitiesGuidParentsGetOpts - Optional Parameters:
     * @param "ParentTypes" (optional.String) -  parentTypes is a comma separated list of parent types, for example, Component,Package_Template.


*/

type EntitiesApiApiEntitiesGuidParentsGetOpts struct { 
	ParentTypes optional.String
}

func (a *EntitiesApiService) ApiEntitiesGuidParentsGet(ctx context.Context, guid string, localVarOptionals *EntitiesApiApiEntitiesGuidParentsGetOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/entities({guid})/parents"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", fmt.Sprintf("%v", guid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ParentTypes.IsSet() {
		localVarQueryParams.Add("parentTypes", parameterToString(localVarOptionals.ParentTypes.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
EntitiesApiService In order to assist with creation of Product Candidate structures CPQ provides a resource that will return, for any entity, a product candidate focused structure.
Inside the response structure there will be a single instance for every child entity that exists within the product specification. This is irrespective of the cardinality on the relations involved.   This means that the structure will in most cases not be valid for the validation service. The data though is in the correct format to be worked with to construct the input by duplicating or removing entries from the XML.  &lt;para&gt;  Within each child entity all of the configurable data items (those that inherit from TConfigurable_Fact and TSpecCharUse) will also be included as CharacteristicUse items. Again all values will be shown which will make the structure invalid in most cases.  &lt;/para&gt;&lt;para&gt;  Also in order to assist with the understanding of the produced structure there are a number of attributes that are added to the output that are not part of the Product Candidate xsd structure. These elements are all marked with the attribute ‘Remove &#x3D; “true”’  to allow them to be easily taken out of the structure. These attributes provide the name and typing of the entities involved and also provide the cardinalities of the relations and configurable items alongside the dates for any relations.  &lt;/para&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param inputGuid inputGuid is the GUID of the product specification that a candidate is required for.


*/
func (a *EntitiesApiService) ApiEntitiesInputGuidProductcandidateGet(ctx context.Context, inputGuid string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/entities({inputGuid})/productcandidate"
	localVarPath = strings.Replace(localVarPath, "{"+"inputGuid"+"}", fmt.Sprintf("%v", inputGuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
EntitiesApiService Returns a list of all entities that are of, or derive from, a given type and are classified or not classified by a given set of classification GUIDs.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param instanceTypeName instanceTypeName is the name of the type that contains the classification element of interest,              for example, Package, Component, or Bundle.
 * @param classifications &lt;main&gt;A comma separated list of classification packets that define the classification on which to match.  You may pass multiple packets and each packet has the following format:&lt;/main&gt;  &lt;sub&gt;1. [CLASSIFICATIONELEMENTNAME; CLASSIFICATIONGUIDS; MATCHALLCLASSIFICATION; CANNEVEREXIST]&lt;/sub&gt;  &lt;sub&gt;2. CLASSIFICATIONELEMENTNAME - is the name of the schema element that holds the classifications on which they query is filtering.&lt;/sub&gt;  &lt;sub&gt;3. CLASSIFICATIONGUIDS - is a comma-separated list that represents all the classifications on which the query is filtering.&lt;/sub&gt;  &lt;sub&gt;4. MATCHALLCLASSIFICATION - is either TRUE or FALSE to specify whether the query results need to match ALL of these or just ANY.&lt;/sub&gt;  &lt;sub&gt;5. CANNEVEREXIST - either true or false to specify whether we want to return entities that lack the Element name (Optional)&lt;/sub&gt;
 * @param optional nil or *EntitiesApiApiEntitiesInstanceTypeNameClassificationsClassificationsGetOpts - Optional Parameters:
     * @param "OperationType" (optional.String) -  operationType is either “classified” or “notClassified” to indicate whether or not to classify              the entity by the list of classifications.


*/

type EntitiesApiApiEntitiesInstanceTypeNameClassificationsClassificationsGetOpts struct { 
	OperationType optional.String
}

func (a *EntitiesApiService) ApiEntitiesInstanceTypeNameClassificationsClassificationsGet(ctx context.Context, instanceTypeName string, classifications string, localVarOptionals *EntitiesApiApiEntitiesInstanceTypeNameClassificationsClassificationsGetOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/entities({instanceTypeName})/Classifications({classifications})"
	localVarPath = strings.Replace(localVarPath, "{"+"instanceTypeName"+"}", fmt.Sprintf("%v", instanceTypeName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"classifications"+"}", fmt.Sprintf("%v", classifications), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.OperationType.IsSet() {
		localVarQueryParams.Add("operationType", parameterToString(localVarOptionals.OperationType.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
EntitiesApiService Return the schema currently used by the Entities.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().


*/
func (a *EntitiesApiService) ApiEntitiesSchemaGet(ctx context.Context) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/entities/Schema"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
EntitiesApiService Returns a list of all entities that are of a given type or derive from a given type, are classified by a given set of classification Guids and have a given set of characteristics
Multiple characteristic, facts and classification packets can be added by appending each element set inside square brackets []. Each additional packet will be combined with the others using “AND” logic so all must match.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *EntitiesApiApiEntitiesWithClassificationsAndCharacteristicsGetOpts - Optional Parameters:
     * @param "Classifications" (optional.String) -  &lt;main&gt;A comma separated list of classification packets that define the classification on which to match.  You may pass multiple packets and each packet has the following format:&lt;/main&gt;  &lt;sub&gt;1. [CLASSIFICATIONELEMENTNAME; CLASSIFICATIONGUIDS; MATCHALLCLASSIFICATION; CANNEVEREXIST; NOT]&lt;/sub&gt;  &lt;sub&gt;2. CLASSIFICATIONELEMENTNAME - is the name of the schema element that holds the classifications on which they query is filtering.&lt;/sub&gt;  &lt;sub&gt;3. CLASSIFICATIONGUIDS - is a comma-separated list that represents all the classifications on which the query is filtering.&lt;/sub&gt;  &lt;sub&gt;4. MATCHALLCLASSIFICATION - is either TRUE or FALSE to specify whether the query results need to match ALL of these or just ANY.&lt;/sub&gt;  &lt;sub&gt;5. CANNEVEREXIST - either true or false to specify whether we want to return entities that lack the Element name (Optional)&lt;/sub&gt;  &lt;sub&gt;6. NOT - an optional parameter to allow the filter to be inverted&lt;/sub&gt;
     * @param "InstanceTypeName" (optional.String) -  instanceTypeName is the name of the type that contains the classification element of interest,              for example, Package, Component, or Bundle.
     * @param "Characteristics" (optional.String) -  &lt;main&gt;A comma separated list of characteristics packets that define the characteristics on which to match.  You may pass multiple packets and each packet has the following format:&lt;/main&gt;  &lt;sub&gt;1. [CHARACTERISTICELEMENTNAME; CHARACTERISTICGUIDS; MATCHALLCHARACTERISTICS; CANNEVEREXIST; NOT]&lt;/sub&gt;  &lt;sub&gt;2. CHARACTERISTICELEMENTNAME - is the name of the schema element that holds the characteristics on which they query is filtering.&lt;/sub&gt;  &lt;sub&gt;3. CHARACTERISTICNGUIDS - is a comma-separated list that represents all the characteristics on which the query is filtering.&lt;/sub&gt;  &lt;sub&gt;4. MATCHALLCHARACTERISTICS - is either TRUE or FALSE to specify whether the query results need to match ALL of these or just ANY.&lt;/sub&gt;  &lt;sub&gt;5. CANNEVEREXIST - either true or false to specify whether we want to return entities that lack the Element name (Optional)&lt;/sub&gt;  &lt;sub&gt;6. NOT - an optional parameter to allow the filter to be inverted&lt;/sub&gt;


*/

type EntitiesApiApiEntitiesWithClassificationsAndCharacteristicsGetOpts struct { 
	Classifications optional.String
	InstanceTypeName optional.String
	Characteristics optional.String
}

func (a *EntitiesApiService) ApiEntitiesWithClassificationsAndCharacteristicsGet(ctx context.Context, localVarOptionals *EntitiesApiApiEntitiesWithClassificationsAndCharacteristicsGetOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/entities/WithClassificationsAndCharacteristics"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Classifications.IsSet() {
		localVarQueryParams.Add("classifications", parameterToString(localVarOptionals.Classifications.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InstanceTypeName.IsSet() {
		localVarQueryParams.Add("instanceTypeName", parameterToString(localVarOptionals.InstanceTypeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Characteristics.IsSet() {
		localVarQueryParams.Add("characteristics", parameterToString(localVarOptionals.Characteristics.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
EntitiesApiService Returns a list of all entities that: are of, or derive from, a given type   and that are classified by a given set of classification Guids  and/or have a given set of characteristics and/or have given fact values.
Each of the parameters on the query is optional with the exception of the InstanceTypeName so this query can be used to search for any and all types of entity restricting it by any of the properties available.  Multiple characteristic, facts and classification packets can be added by appending each element set inside square brackets []. Each additional packet will be combined with the others using “AND” logic so all must match.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *EntitiesApiApiEntitiesWithGetOpts - Optional Parameters:
     * @param "Classifications" (optional.String) -  &lt;main&gt;A comma separated list of classification packets that define the classification on which to match.  You may pass multiple packets and each packet has the following format:&lt;/main&gt;  &lt;sub&gt;1. [CLASSIFICATIONELEMENTNAME; CLASSIFICATIONGUIDS; MATCHALLCLASSIFICATION; CANNEVEREXIST; NOT]&lt;/sub&gt;  &lt;sub&gt;2. CLASSIFICATIONELEMENTNAME - is the name of the schema element that holds the classifications on which they query is filtering.&lt;/sub&gt;  &lt;sub&gt;3. CLASSIFICATIONGUIDS - is a comma-separated list that represents all the classifications on which the query is filtering.&lt;/sub&gt;  &lt;sub&gt;4. MATCHALLCLASSIFICATION - is either TRUE or FALSE to specify whether the query results need to match ALL of these or just ANY.&lt;/sub&gt;  &lt;sub&gt;5. CANNEVEREXIST - either true or false to specify whether we want to return entities that lack the Element name (Optional)&lt;/sub&gt;  &lt;sub&gt;6. NOT - an optional parameter to allow the filter to be inverted&lt;/sub&gt;
     * @param "InstanceTypeName" (optional.String) -  instanceTypeName is the name of the type that contains the classification element of interest, for example, Package, Component, or Bundle.
     * @param "Characteristics" (optional.String) -  &lt;main&gt;A comma separated list of characteristics packets that define the characteristics on which to match.  You may pass multiple packets and each packet has the following format:&lt;/main&gt;  &lt;sub&gt;1. [CHARACTERISTICELEMENTNAME; CHARACTERISTICGUIDS; MATCHALLCHARACTERISTICS; CANNEVEREXIST; NOT]&lt;/sub&gt;  &lt;sub&gt;2. CHARACTERISTICELEMENTNAME - is the name of the schema element that holds the characteristics on which they query is filtering.&lt;/sub&gt;  &lt;sub&gt;3. CHARACTERISTICNGUIDS - is a comma-separated list that represents all the characteristics on which the query is filtering.&lt;/sub&gt;  &lt;sub&gt;4. MATCHALLCHARACTERISTICS - is either TRUE or FALSE to specify whether the query results need to match ALL of these or just ANY.&lt;/sub&gt;  &lt;sub&gt;5. CANNEVEREXIST - either true or false to specify whether we want to return entities that lack the Element name (Optional)&lt;/sub&gt;  &lt;sub&gt;6. NOT - an optional parameter to allow the filter to be inverted&lt;/sub&gt;
     * @param "FactElementFilter" (optional.String) -  &lt;main&gt;A list of &#39;fact value&#39; packets which define what fact-values you want to match on.  You may pass multiple packets and each packet has the following format:&lt;/main&gt;  &lt;sub&gt;1. [FACTVALUE; FACTVALUEGUIDS; MATCHALLFACTVALUES; CANNEVEREXIST; NOT]&lt;/sub&gt;  &lt;sub&gt;2. FACTVALUE - The schema element name that contains the fact values to filter on.&lt;/sub&gt;  &lt;sub&gt;3. FACTVALUEGUIDS - is a comma seperated list that represents all the fact values on which the query is filtering.&lt;/sub&gt;  &lt;sub&gt;4. MATCHALLFACTVALUES - is either TRUE or FALSE to specify whether the query results need to match ALL of these or just ANY.&lt;/sub&gt;  &lt;sub&gt;5. CANNEVEREXIST - either true or false to specify whether we want to return entities that lack the Element name (Optional)&lt;/sub&gt;  &lt;sub&gt;6. NOT - an optional parameter to allow the filter to be inverted&lt;/sub&gt;
     * @param "Categories" (optional.String) -  &lt;main&gt;A list of &#39;categories value&#39; packets which define what categories you want to match on.  You may pass multiple packets and each packet has the following format:&lt;/main&gt;  &lt;sub&gt;1. [Category Ids; IncludeChildCategories]&lt;/sub&gt;  &lt;sub&gt;2. Category Ids - the comma separated list of category ids.&lt;/sub&gt;  &lt;sub&gt;3. IncludeChildCategories - boolean value indicating if filter apply on child categories as well&lt;/sub&gt;
     * @param "AvailableDate" (optional.String) -  Target date. If supplied, only entities available on this date are returned. Otherwise results are not date filtered


*/

type EntitiesApiApiEntitiesWithGetOpts struct { 
	Classifications optional.String
	InstanceTypeName optional.String
	Characteristics optional.String
	FactElementFilter optional.String
	Categories optional.String
	AvailableDate optional.String
}

func (a *EntitiesApiService) ApiEntitiesWithGet(ctx context.Context, localVarOptionals *EntitiesApiApiEntitiesWithGetOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/entities/With"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Classifications.IsSet() {
		localVarQueryParams.Add("classifications", parameterToString(localVarOptionals.Classifications.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InstanceTypeName.IsSet() {
		localVarQueryParams.Add("instanceTypeName", parameterToString(localVarOptionals.InstanceTypeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Characteristics.IsSet() {
		localVarQueryParams.Add("characteristics", parameterToString(localVarOptionals.Characteristics.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FactElementFilter.IsSet() {
		localVarQueryParams.Add("factElementFilter", parameterToString(localVarOptionals.FactElementFilter.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Categories.IsSet() {
		localVarQueryParams.Add("categories", parameterToString(localVarOptionals.Categories.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AvailableDate.IsSet() {
		localVarQueryParams.Add("availableDate", parameterToString(localVarOptionals.AvailableDate.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
